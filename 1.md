```angular2html
*1.controller: 控制层，接收前端发送的请求，对请求进行处理，响应数据;
*2.service: 业务逻辑测温那个，处理具体的业务逻辑;
*3.dao: Data Access Object 数据访问层，负责数据的访问操作，包括数据的增删改查;
三层架构执行顺序：1,2,3
```

```angular2html
1.控制反转： inversion of Control,对象的创建控制权由程序自身转移到外部(容器)
例如： public class EmpServiceA implements EmpService{}; EmpServiceA 放到容器；
2.依赖注入： dependency injection,容器为应用程序提供运行时所需资源；
3.Bean对象： IOC(控制反转)容器中创建，管理的对象.
```

IOC&DI： 控制反转和依赖注入
```
1.Service层及Dao层的实现类交给 IOC 容器管理
2.为 Controller 及 Service 注入运行时依赖的对象

@Component: 将当前类交给 IOC 容器，成为 IOC容器中的 bean;
@Component
public class EmpServiceA implements EmpService{}

@Autowired: 运行时，IOC融合其会提供该类型的 bean 对象，并赋值给该变量 - 依赖注入
@Autowired
private EmpService empService;
```

Bean 的声明, 
```angular2html
若需将某个对象交给 IOC 容器，需要在对应类上加如下注释
1. @Component: 声明 bean 的基础注解
2. @Controller: 标注在控制类上
3. @Service: 标注在业务类上
4. @Repository: 标注在数据访问类上

5. @RestController： 已经包含 @Controller 了
6. @ComponentScan： 组件扫描
7.不怎么重要的 @SpringBootApplication 默认扫描当前包及其子包， 已经包含 @ComponentScan 组件扫描
```

##### Bean 注入
@Autowired 注解默认是按照类型来进行声明的，若出现多个相同类型的 bean,将会报错;
解决多个相同类型冲突问题
1. @Primary: 加在哪个实现类上就默认实现哪个
```
@Primary
@Service
public class EmpServiceA implements EmpService {}

若有冲突，默认选中 bean 为 EmpServiceA
```

2. @Qualifier: @Qualifier 中指定哪个就是哪个
```
@RestController
public class EmpController {
    @Qualifier("empServiceA")
    @Autowired
    private EmpService empService;
}
```
3. @Resource: 由 jdk 提供
```
@RestController
public class EmpController {
    @Resource(name="empServiceB")
    private EmpService empService;
    
}
```

*@Resource 和 @Autowired 的区别
1. @Autowired 是 spring 框架提供的注解，@Resource 是 JDK 提供的注解
2. @Autowired 是按照类型注入，@Resource 是按照名称注入
